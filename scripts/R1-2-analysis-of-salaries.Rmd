---
title: "Finding the story in salaries data"
author: "Liz Lucas, IRE"
output: html_document
editor_options: 
  markdown: 
    wrap: 72
---

Now you'll put into practice the functions you've learned so far to
interrogate some salary data from Bloomington, Indiana, that came from a
records request. We have cleaned up the data a little for the purposes
of this class, but left it in spreadsheet format, so shortly you'll
learn how to import data from an Excel file (either .xls or .xlsx).

First, open up `salaries.xlsx` in Excel by double-clicking on the file
in Finder. Note that it has two tabs: one with the data, an another with
notes on the source. This is best practice for keeping track of when and
where you received data. But you only want to import the first tab into
R for analysis.

### Part One: Installing Packages

When you first install R on your computer it comes with a wide variety
of functions that are collectively called "base R."

Base R works just fine, and you'll often find that the base functions do
what you want more clearly or efficiently than anything else. But to do
the really cool stuff, you'll need to download additional packages. Each
package comes with new verbs that extend base R and often provide
shortcuts or additional actions.

You can think of installing packages as adding new verbs to your
vocabulary. Think of base R as giving you the verb "turn on." If you
were to install a hypothetical "southernisms" package, you might get a
verb called "cut on." Different verbs. Same action.

In other cases, packages give you new verbs that do a bunch of things at
once. For example, imagine a theoretical package called "PBJ" that has a
function called `make_sandwich()` . In base R you might have to
`get_bread()` and then `spread_pb()` and then `spread_jelly()`. It's
much nicer to just `make_sandwich()`.

The first package that we'll install is called tidyverse. Its really a
package of packages that are used all ... the ... time. You can read
more about the tidyverse and its core packages at
<https://www.tidyverse.org/packages/>

But for now, lets install it. Installing a package in R means
downloading the code from a remote location on to your local computer.
Most often, you are downloading packages from something called "CRAN,"
which is "a network of ftp and web servers around the world that store
identical, up-to-date, versions of code and documentation for R." You
can also install packages from GitHub, but that's a story for a
different class.

To install a package that's on CRAN, we use the `install.packages()`
function from base R. The argument is the name of the package as a
string, contained inside quote marks.

```{r}
#install.packages("tidyverse")
```

When you run that, you will see some action down in your console. You
can also verify that the package has been installed by going over to the
"Packages" tab in R Studio.

**You only need to install packages once.**

Even though you only need to install a package once, you need to load it
every time you start a new R session. To do that, we use the `library()`
function.

```{r}
library(tidyverse)
```

To verify that the package has been correctly loaded into your library
for the current R session, hop on over to the Packages tab in R Studio
and make sure there's a check mark next to the name of the package you
intended to load.

If you're looking for a short-cut on installing packages, you can use
the "Install" button in the "Packages" tab in R Studio. This is probably
OK to use because you only need to install packages once. It's not code
you need to run repeatedly.

There's also a shortcut for loading packages into your library each
session. You can just click or un-click the check box next to the
package name in R Studio. But this isn't a good habit to get into. You
typically want a code chunk at the top of your Rmd file that loads all
the packages you need to run the rest of the work. That way you can just
run the chunk each time. More importantly, it makes clear to other folks
which packages they will need if they want to run your script on their
computer.

Finally, there's a useful shortcut for installing and loading packages.
It's in the `pacman` package, and it's called `p_load()` .

I like it for two reasons. It's an easy way to load multiple packages at
once, and it installs any packages you haven't already downloaded on to
your computer.

```{r}
#install.packages("pacman")

```

```{r}
#pacman::p_load(tidyverse, readxl)
```

There are many functions available in `readxl`, the one you'll use now is read_excel(). This function has an optional argument called "sheet" which allows you to specify, numerically, which sheet or sheets you want
to import. We want the first one:

```{r}
read_excel("../data/salaries.xlsx", sheet=1)
```

**Remember!** The results of any function - including read_excel() - either print to the console or save to a variable. If you want to refer to this data table later and pipe it into functions, you need to save it to a variable. Call it "salaries":

```{r}
salaries <- read_excel("../data/salaries.xlsx", sheet=1)
```

Take a look at the salaries data: click on the word "salaries" in your
Environment (upper right). Take a minute or two to look at the data:
What is one row of data? (One employee) What columns of information do
you have?

We can use a function called `str()` to see the structure of our data
table.

```{r}
str(salaries)
```

Note that there are NAs in the overtime_oncall, hourly_rate, and
salary_2021 columns. NAs are *NULL* values, not blanks.

# Practice

Start with some basic questions:

*Your turn!* How many employees in our data? (You may already know the
answer to this, but write some code anyway!)

*Your turn!* Who made the most in total compensation? Who made the
least? (Hint: use arrange() to sort your data)

*Your turn!* Who made the most in overtime/oncall pay?

What do you see in the results? What questions does that spark for you,
a journalist? What questions might you have for the city?

What is the total payroll for the city? Reminder: when you're no longer
asking questions with regard to specific employees, your unit of
analysis has changed. If you want to look at payroll for the whole city,
you need to do some aggregating. In this case, we want to sum up payroll
for the entire data set:

```{r}
salaries %>% 
  summarise(total_payroll = sum(total_comp))
```

What is the total overtime/oncall pay?

```{r}
salaries %>% 
  summarise(total_payroll = sum(overtime_oncall))
```

Here's where NAs (NULLs) will trip you up. If you sum a column with NAs
in it, R will return an NA. So you need to exclude the NAs in your
summing. Thankfully there is an EASY way to do this; the sum() function
will take an additional argument: `na.rm=T`, which means remove NAs.
Adding it looks like this:

```{r}
salaries %>% 
  summarise(total_payroll = sum(overtime_oncall, na.rm=T))
```

That's why it's important to take note of NAs in your data! Anytime you
want to sum a column with NAs, you need to include this argument in the
aggregate function: `na.rm=T`

*Your turn!* What's the average and median salary for 2021? Hourly rate?
(Note: both of these have NAs, so code accordingly)

# Getting to know your data

There's a very useful function in tidyverse for assessing what's in a
particular column. For example, if you are familiar with SQL, this is
the equivalent of the "golden query." If you regularly use spreadsheets,
this is the equivalent of putting a column in the Rows box and
calculating the count() function on each group.

This function happens to be called count(). Try it out on the job_title
column:

```{r}
salaries %>% 
  count(job_title)
```

You see a list of all unique job titles and how many times each value
appears in the data (i.e. how many rows have that value in the job_title
column). The count() function automatically labels the values column
`n`. Re-sort the results to see which job titles are the most common:

```{r}
salaries %>% 
  count(job_title) %>% 
  arrange(desc(n))
```

*Your turn!* Try using the count() function on department. How clean are
the department names?

Let's see if any employees are in here more than once. We wouldn't
expect them to be since each row is one employee. We'll count the last
name and first name to see how often each unique combination shows up,
and then arrange our results by the descending count.

```{r}
salaries %>% 
  count(last_name, first_name) %>% 
  arrange(desc(n))
```

*Your turn!* Use the filter() to look at the rows for Emily Herr. What
can we learn about her work. Does it make sense that she's in here
twice, or is this potentially an error in the data?

# Asking questions

How many people work for the police department?

```{r}
salaries %>% 
  filter(department == "Police")
```

What's the average total compensation for a police employee?

```{r}
salaries %>% 
  filter(department == "Police") %>% 
  summarise(avg_pay = mean(total_comp))
```

*Your turn!* Calculate the average compensation for each job title
within the Police department:

How does the average police compensation compare to other departments?
Calculate the average compensation by department, using group_by():

```{r}
salaries %>% 
  group_by(department) %>% 
  summarise(avg_comp = mean(total_comp)) %>% 
  arrange(desc(avg_comp))
```

Just like a pivot table in Excel, we can add more calculations to this
to give us more context. Right now we're look at the **average
compensation** by department. Let's add two more columns: **total
compensation** by department and the **number of employees** in each
department.

```{r}
salaries %>% 
  group_by(department) %>% 
  summarise(avg_comp = mean(total_comp),
            total_comp = sum(total_comp),
            num_employees = n())
```

*Your turn!* Let's find the same calculations for the job titles. For
each job title, calculate the following:

-   Average compensation

-   Total compensation

-   Number of people with that job title

Arrange your results by the job title that has the highest average
compensation.

Let's add one more layer to this. It makes sense that there are some
jobs held by one person that pay a lot (ie. mayor, chief) so let's
filter our results to only show us [jobs held by at least 10
people]{.underline}. We can do this by filtering after we do our
calculations.

```{r}
salaries %>% 
  group_by(job_title) %>% 
  summarise(avg_comp = mean(total_comp),
            total_comp = sum(total_comp),
            num_employees = n()) %>% 
  filter(num_employees > 10)
```

Let's dig into the job titles a bit. So far we have only looked at exact
matches, but text fields can have some (or a lot of) variation in them.
For example, lots of jobs could have the word 'Director' in them.

If we wanted to find every job title with that word in it, we can use a
function called `grepl()` ***INSIDE*** our `filter()` function. This
performs a wildcard match.

```{r}
salaries %>% 
  filter(grepl("Director", job_title))
```

In this example, we can see we have 41 employees with the word
'Director' in their job title. (Remember, R is case sensitive!)

We'll store these directors to their own data frame so we can run more
queries against them.

```{r}
directors <- salaries %>% filter(grepl("Director", job_title))
```

*Your turn!* Which department pays the highest average salary to people
with director in their job title?

*Your turn!* Let's return to the original salaries data frame. Use
filter and grepl to find all the people who work in the various
Utilities departments. (If you need to refresh your memory, click on the
word "salaries" in your Environment (upper right).) Once you've
successfully run this code, store these employees to their own data
frame called **utilities**.

*Your turn!* Which job in the various Utilities department pays the
best? (This question is intentionally vague! Think about the various
calculations you can do and pick one -- or multiple -- to try to come up
with a conclusion.)

# Extra practice!

1.  What do people with the word 'Specialist' in their job title make in
    total compensation, on average?

2.  What do interns make?

3.  Which department paid out the most in overtime/on-call pay?

4.  Which department has the most employees paid hourly?

5.  For police employees, find the percent of their total compensation
    comes from overtime for each employee.

    Do this in two steps: First, create a data frame called police of
    just employees who work for the police department. If you do this
    correctly, you will see police show up in your Environment sidebar.
    Then, using this new police data frame, you will use mutate() to add
    a column and do a percent of total calculation.
